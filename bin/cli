#!/usr/bin/env node

const humanizeDuration = require('humanize-duration');
const finalPM = require('../');
const cli = require('../lib/cli-util');

finalPM.registerProcessHandlers();

cli.parseArgs();

const args = cli.args;

run();

async function run() {
    const lookupPaths = args.config.slice(0);

    if (!lookupPaths.length) {
        lookupPaths.push('.');
    }

    const paths = await Promise.all(lookupPaths.map(finalPM.config.resolveConfig));

    if (paths.includes(null) && args.config.length) {
        cli.err(`No configuration file found at: ${lookupPaths[paths.indexOf(null)]}`);
        process.exit(1);
    }

    const configs = await Promise.all(paths.map(async (path) =>  {
        try {
            return await finalPM.config.getConfig({
                path: path,
                args: args.set
            });
        } catch (error) {
            if (error.name === 'ConfigError') {
                cli.invalidConfig(error.path, error.message);
            }

            throw error;
        }
    }));

    const normalizedConfigs = finalPM.config.normalizeArray(configs);

    for (let config of normalizedConfigs) {
        await runWithConfig(config);
    }
}

async function runWithConfig(config) {
    cli.debug("Connection", "Connecting to " + config.socket);

    let client;

    try {
        client = await connectOrLaunch(config);
    } catch (error) {
        if (error.name === 'ConnectionError') {
            cli.err("Connection", error.message);
            return;
        }
        
        throw error;
    }

    const api = client.api();

    if (['add', 'start', 'restart'].includes(args.action) &&
            config.applications.length > 0 && !args['no-upload']) {

        if (!await uploadConfigurations(api, config)) {
            return close();
        }
    }

    cli.debug("Download", "Retrieving application and process lists");

    const info = await api.Daemon.info();

    let actions = [];

    if (args.action === 'show') {
        printInfo(info); 
    }
    
    if (args.action === 'delete') {
        actions = actions.concat(deleteAction(info));
    }

    if (args.action === 'start' || args.action === 'restart') {
        actions = actions.concat(startAction(info));
    }
    
    if (args.action === 'stop' || args.action === 'kill') {
        actions = actions.concat(stopAction(info, args.action));
    }
    
    if (args.action === 'scale') {
        actions = actions.concat(scaleAction(info));
    }
    
    if (args.wait) {
        actions.push({
            name: 'wait'
        });
    }

    if (args.kill) {
        actions.push({
            name: 'kill'
        });
    }
    
    if (actions.length) {
        cli.log("[yellow]{Executing}", makeSummary(actions));
            
        const results = await api.Daemon.all(actions);
        const failed = [];

        results.forEach((result, i) => {
            if (!result.success) {
                failed.push(actions[i]);
            }
        });

        if (failed.length) {
            cli.log("[red]{Executing}", "[red bold]{Failed:} " + makeSummary(failed));
        } else {
            cli.log("[green]{Executing}", "[green bold]{Success.}");
        }
    }
    
    close();

    function close() {
        cli.debug("Connection", "Closing Connection");

        client._socket.close();
    }
}

async function uploadConfigurations(api, config) {
    cli.debug("Upload", `Uploading application configuration: ` +
                  `[bold]{${config.applications.map(_ => _.name).join(' ')}}`);

    const appNames = args.select.map(arg => arg.app).filter(_ => _);

    const applications = config.applications.filter(app => {
        return appNames.includes('all') || appNames.includes(app.name);
    });

    const results = await Promise.all(applications.map(app => {
        return api.Daemon.add([app, args.force]);
    }));

    let failed = false;

    const updated = [];
    const added = [];

    results.forEach((result, i) => {
        const app = applications[i];

        if (result.success) {
            if (result.changed === true) {
                added.push(app['name']);
            } else if (result.changed.length) {
                updated.push(`[bold]{${app['name']}}{[yellow]{${result.changed.join(',')}}}`);
            }
            return;
        }

        let reason = "for an unknown reason";

        if (result.reason === 'path') {
            reason = "because its configuration path changed"; 
        }

        cli.err("Upload", `Daemon rejected configuration for [bold]{${app.name}} ` +
                          `${reason}.\nTry using --force or --no-upload.`);

        failed = true;
    });

    if (added.length) {
        cli.log("[bold green]{Added}", `[bold]{${added.join(' ')}}`);
    }
    
    if (updated.length) {
        cli.log("[bold yellow]{Updated}", updated.join(' '));
    }

    return !failed;
}

function makeSummary(actions) {
    const counter = {};

    for (const action of actions) {
        counter[action.name] = (counter[action.name] || 0) + 1;
    }

    const plan = [];
    
    if (counter['delete']) {
        plan.push(`delete ${counter['delete']} applications`);
    }
    
    ['stop', 'start', 'kill'].forEach((action) => {
        const count = counter[action + 'Process'];
        if (count) {
            plan.push(`${action} ${count} process${count > 1 ? 'es' : ''}`);
        }
    });
    
    if (counter['wait']) {
        plan.push("wait for completion");
    }

    if (counter['kill']) {
        plan.push("kill daemon");
    }

    return "[bold]{" + cli.capitalize(plan.join('}, then [bold]{')) + '}.';
}

function printInfo(info) {
    const selected = filterInfo(info, args.select);

    cli.reply('');
    cli.reply(` [bold white]{Applications:} [bold]{${info.applications.map(_ => _.name).join(' ')}}`);
    cli.reply('');
    
    const data = [
        [ 'Application/Nr.', 'ID', 'PID (OS)', 'Uptime', 'Crashes' ].map(_ => `[bold]{${_}}`)
    ];

    let zombies = false;
    
    for (const name in selected.processes) {
        if (!Object.prototype.hasOwnProperty.call(selected.processes, name))
            continue;

        const gen = selected.processes[name];

        if (gen.length === 0) continue;

        data.push([`[bold]{Gen: ${name}} (${gen.length})`, '', '', '', '']);

        for (const proc of gen) {
            let name = `${proc['app-name']}/${proc['number']}`;

            if (proc['app']) {
                name += ' [red]{(old)}';
            }
            
            if (proc.killing) {
                name += ' [green]{(Z)}';
                zombies = true;
            }

            const runtime = Date.now() - new Date(proc['start-time']).getTime();
            let humanRuntime = humanizeDuration(Math.abs(runtime), {round:true});

            if (runtime < 0) {
                humanRuntime = "- " + humanRuntime + " [blue]{(!)}";
            }

            data.push([name, proc['id'], proc['pid'], humanRuntime, proc['crashes']]);
        }
    }

    const legend = " [red]{(old)} [italic]{Outdated Configuration}" +
                   " [blue]{(!)} [italic]{Start Delay}" +
                   " [green]{(Z)} [italic]{Zombie}\n";

    cli.reply(cli.table(data) + legend);

    if (zombies) {
        cli.reply("Hint", "You have [green]{Zombie} processes. If they don't go away you should\n" +
                          "get rid of them manually and check your signal handling.");
    }
}

function scaleAction(info) {
    const selected = filterInfo(info, args.select);
    const actions = [];

    function procFilter(app) {
        return (proc) => {
            return proc['app-name'] === app.name;
        };
    }

    for (const app of selected.applications) {
        const running = selected.processes.running.filter(procFilter(app))
            .concat(selected.processes.new.filter(procFilter(app)))
            .sort((a, b) => a.number - b.number);

         
        let number = running.length;
        const max = app['instances'];

        for (; number > max; number--) {
            actions.push({
                name: 'stopProcess',
                args: [{
                    id: running[number - 1].id
                }]
            });
        }
        
        for (let i = 0; i < max; i++) {
            if (running.find(proc => proc.number === i))
                continue;

            actions.push({
                name: 'startProcess',
                args: [app.name, {
                    number: i
                }]
            });
        }
    }

    return actions;
}

function stopAction(info, action) {
    const selected = filterInfo(info, args.select);
    const actions = [];
    const actionName = action + 'Process';

    for (const process of selected.all) {
        actions.push({
            name: actionName,
            args: [{
                id: process.id
            }]
        });
    }
    
    return actions;
}

function startAction(info) {
    const actions = [];

    for (const selector of args.select) {
        if (!selector.app)
            continue;

        const apps = selector.app === 'all' ?
            info.applications :  info.applications.filter(_ => _.name === selector.app);

        if (apps.length === 0) {
            cli.err("Selector", `No such application: [bold]{${selector.app}}`);
            continue;
        }

        for (const app of apps) {
            if (typeof selector.number === 'number') {
                actions.push({
                    name: 'startProcess',
                    args: [app.name, {
                        number: selector.number
                    }]
                });
                continue;
            }

            for (var i = 0; i < app.instances; i++) {
                actions.push({
                    name: 'startProcess',
                    args: [app.name, {
                        number: i
                    }]
                });
            }
        }
    }

    return actions;
}

function deleteAction(info) {
    const selected = filterInfo(info, args.select);
    const actions = [];

    for (const app of selected.applications) {
        actions.push({
            name: 'delete',
            args: [app.name]
        });
    }

    return actions;
}

function filterInfo(info, selectors) {
    const applications = info.applications.filter((app) => {
        for (const select of selectors) {
            if (select.pid || select.id || select.number)
                continue;

            if (select.app === 'all' || select.app === app.name)
                return true;
        }

        return false;
    });

    const processes = {};
    let all = []; 

    for (let gen of Object.keys(info.processes)) {
        processes[gen] = info.processes[gen].filter(processFilter(gen));
        all = all.concat(processes[gen]);
    }

    function processFilter(generation) {
        return (process) => {
            for (const select of selectors) {
                if (select.gen && select.gen !== generation)
                    continue;

                if (select.app && select.app !== 'all' && select.app !== process['app-name'])
                    continue;

                if (!match('number', select, process) ||
                    !match('id', select, process) ||
                    !match('pid', select, process)) {

                    continue;
                }
                
                return true;
            }

            return false;
        };
    }

    function match(name, select, process) {
        return typeof select[name] === 'undefined' || select[name] === process[name];
    }

    return {
        applications,
        processes,
        all
    };
}
 
async function connectOrLaunch(config) {
    try {
        return await finalPM.client.connect(config['socket']);
    } catch (error) {
        if ((error.name === 'ConnectionError')) {
            if (config['is-local']) {
                cli.log("Daemon", "Starting Daemon");
                await finalPM.daemon.launch(config);
                return finalPM.client.connect(config['socket']);
            }
        } 

        throw error;
    }
}

