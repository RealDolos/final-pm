#!/usr/bin/env node

const finalPM = require('../');
const util = require('util');
const commandLineArgs = require('command-line-args');
const commandLineUsage = require('command-line-usage');
const argsDefinition = require('../cli-args.js');
const stripAnsi = require('strip-ansi');
const ansi = require('ansi-escape-sequences');

finalPM.registerProcessHandlers();

let args;
try {
    args = commandLineArgs(argsDefinition.options, {
        partial: false,
        disableGreedyMultiple: true
    });
} catch (e) {
    invalidArgument(e.message);
}

if (args['help-usage']) {
    console.log(commandLineUsage(argsDefinition.usage));
    process.exit(0);
}

if (args['help-generations']) {
    console.log(commandLineUsage(argsDefinition.generations));
    process.exit(0);
}

if (args['help-example']) {
    console.log(commandLineUsage(argsDefinition.example));
    process.exit(0);
}

if (args['help-configuration']) {
    console.log(commandLineUsage(argsDefinition.configuration));
    process.exit(0);
}

if (args['help-all']) {
    console.log(commandLineUsage(argsDefinition.helpAll));
    process.exit(0);
}

if (args['help'] || args.actionSelect.length === 0 && !args.kill && !args.launch) {
    console.log(commandLineUsage(argsDefinition.help));
    process.exit(0);
}

if (args.actionSelect.length === 1) {
    invalidArgument("Missing option: Selector is missing.");
}

async function run() {
    const paths = await Promise.all(
        args.config.map(finalPM.config.resolveConfig));

    paths.forEach((path, i) => {
        if (!path) {
            err(`Config file not found: ${args.config[i]}`);
            process.exit(1);
        }
    });

    const configs = await Promise.all(paths.map(async (path) =>  {
        try {
            return await finalPM.config.getConfig({
                path: path,
                args: args.set
            });
        } catch (error) {
            if (error.name === 'ConfigError') {
                invalidConfig(error.path, error.message);
            }

            throw error;
        }
    }));

    const normalizedConfigs = finalPM.config.normalizeArray(configs);

    for (let config of normalizedConfigs) {
        await runWithConfig(config);
    }
}

async function runWithConfig(config) {
    debug("Connection", "Connecting to " + config.socket);
    let client;

    try {
        client = await connectOrLaunch(config);
    } catch (error) {
        if (error.name === 'ConnectionError') {
            err("Connection", error.message);
            return;
        }
        
        throw error;
    }

    const api = client.api();

    log("Load", "Uploading application configuration: " + config.applications.map(_ => _.name).join(' '));

    await api.Daemon.load(config.applications);

    if (args.kill) {
        log("Daemon", "Stopping Daemon");
        api.Daemon.kill()
    }

    debug("Connection", "Closing Connection");

    client._socket.close()
}

async function connectOrLaunch(config) {
    try {
        return await finalPM.client.connect(config['socket']);
    } catch (error) {
        if ((error.name === 'ConnectionError')) {
            if (config['is-local']) {
                log("Daemon", "Starting Daemon");
                await finalPM.daemon.launch(config);
                return finalPM.client.connect(config['socket']);
            }
        } 

        throw error;
    }
}

function invalidConfig(path, ...info) {
    err("Configuration", path, ...info);
    err("Configuration", "Check \"final-pm --help\" for example configurations.");
    process.exit(1);
}

function invalidArgument(...info) {
    err("Arguments", ...info);
    err("Arguments", "Check \"final-pm --help\" for the correct syntax.");
    process.exit(1);
}

function debug(...out) {
    if (!args.verbose) return;

    console.log(makeLogLine(
        ['[gray]{DEBUG}'].concat(out),
        process.stdout.isTTY
    ));
}

function log(...args) {
    console.log(makeLogLine(
        ['[white]{INFO }'].concat(args),
        process.stdout.isTTY
    ));
}

function err(...args) {
    console.error(makeLogLine(
        ['[red]{ERROR}'].concat(args),
        process.stderr.isTTY
    ));
}

function makeLogLine(args, format) {
    const last = args[args.length - 1];
    const pre = `[[bold]{${args.slice(0, args.length - 1).join('}] [[bold]{')}}] `;
    const line = ansi.format(last.split('\n').map(line => pre + line).join('\n'));
    
    if (format) {
        return line;
    }

    return stripAnsi(line);
}

run();
