#!/usr/bin/env node

const humanizeDuration = require('humanize-duration');
const util = require('util');
const finalPM = require('../');
const cli = require('../lib/cli-util');

finalPM.registerProcessHandlers();

cli.parseArgs();

const args = cli.args;

async function run() {
    const paths = await Promise.all(
        args.config.map(finalPM.config.resolveConfig));

    paths.forEach((path, i) => {
        if (!path) {
            cli.err(`No configuration file found at: ${args.config[i]}`);
            process.exit(1);
        }
    });

    const configs = await Promise.all(paths.map(async (path) =>  {
        try {
            return await finalPM.config.getConfig({
                path: path,
                args: args.set
            });
        } catch (error) {
            if (error.name === 'ConfigError') {
                cli.invalidConfig(error.path, error.message);
            }

            throw error;
        }
    }));

    const normalizedConfigs = finalPM.config.normalizeArray(configs);

    for (let config of normalizedConfigs) {
        await runWithConfig(config);
    }
}

async function runWithConfig(config) {
    cli.debug("Connection", "Connecting to " + config.socket);

    let client;

    try {
        client = await connectOrLaunch(config);
    } catch (error) {
        if (error.name === 'ConnectionError') {
            cli.err("Connection", error.message);
            return;
        }
        
        throw error;
    }

    const api = client.api();

    if (config.applications.length > 0 && !args['no-upload']) {
        cli.log("Upload", `Uploading application configuration: ` +
                      `[bold]{${config.applications.map(_ => _.name).join(' ')}}`);

        const results = await Promise.all(config.applications.map(app => {
            return api.Daemon.load([app, args.force]);
        }));

        let failed = false;
        results.forEach((result, i) => {
            if (result.success)
                return;

            const app = config.applications[i];

            let reason = "for an unknown reason";

            if (result.reason === 'path') {
                reason = "because its configuration path changed"; 
            }

            cli.err("Upload", `Daemon rejected configuration for [bold]{${app.name}} ` +
                              `${reason}.\nTry using --force or --no-upload.`);

            failed = true;
        });

        if (failed) {
            return close();
        }
    }

    cli.debug("Download", "Retrieving application and process lists");

    const info = await api.Daemon.info();

    let actions = [];

    if (args.action === 'show') {
        printInfo(info); 
    }

    if (args.action === 'start') {
        actions = actions.concat(startAction(info));
    }
    
    if (args.action === 'stop') {
        actions = actions.concat(stopAction(info, 'stop'));
    }
    
    if (args.action === 'kill') {
        actions = actions.concat(stopAction(info, 'kill'));
    }
    
    if (args.wait) {
        cli.log("Action", `Wait for actions to complete`);
        actions.push({
            name: 'wait'
        });
    }

    if (args.kill) {
        cli.log("Action", `Stopping Daemon`);
        actions.push({
            name: 'kill'
        });
    }
        
    await api.Daemon.all(actions)

    close();

    function close() {
        cli.debug("Connection", "Closing Connection");

        client._socket.close()
    }
}

function printInfo(info) {
    const selected = filterInfo(info, args.select);

    cli.reply('');
    
    const data = [
        [ 'Application/Nr.', 'ID', 'PID (OS)', 'Runtime', 'Crashes' ].map(_ => `[bold]{${_}}`)
    ];
    
    for (const name in selected.processes) {
        if (!Object.prototype.hasOwnProperty.call(selected.processes, name))
            continue

        const gen = selected.processes[name];

        if (gen.length === 0) continue;

        data.push([`[bold]{Gen: ${name}} (${gen.length})`, '', '', '', '']);

        for (const proc of gen) {
            let name = `${proc['app-name']}/${proc['number']}`;

            if (proc['app']) {
                name += ' [red]{(old)}';
            }
            
            if (proc.killing) {
                name += ' [green]{(Z)}';
            }

            const runtime = Date.now() - new Date(proc['start-time']).getTime();
            let humanRuntime = humanizeDuration(Math.abs(runtime), {round:true});

            if (runtime < 0) {
                humanRuntime = "- " + humanRuntime + " [blue]{(!)}";
            }

            data.push([name, proc['id'], proc['pid'], humanRuntime, proc['crashes']]);
        }
    }

    const legend = " [red]{(old)} [italic]{Outdated Configuration}" +
                   " [blue]{(!)} [italic]{Start Delay} " +
                   " [green]{(Z)} [italic]{Zombie}\n";

    cli.reply(cli.table(data) + legend);
}

function stopAction(info, action) {
    const selected = filterInfo(info, args.select);
    const actions = [];
    const actionName = action + 'Process';

    for (const process of selected.all) {
        actions.push({
            name: actionName,
            args: [{
                id: process.id
            }]
        });
    }
    
    cli.log("Action", `${cli.capitalize(action)} ${actions.length} processes`); 
    return actions;
}

function startAction(info) {
    const actions = [];

    for (const selector of args.select) {
        if (!selector.app)
            continue;

        const apps = selector.app === 'all' ?
            info.applications :  info.applications.filter(_ => _.name === selector.app);

        if (apps.length === 0) {
            cli.err("Selector", `No such application: [bold]{${selector.app}}`);
            continue;
        }

        for (app of apps) {
            if (typeof selector.number === 'number') {
                actions.push({
                    name: 'startProcess',
                    args: [app.name, {
                        number: selector.number
                    }]
                });
                continue;
            }

            for (var i = 0; i < app.instances; i++) {
                actions.push({
                    name: 'startProcess',
                    args: [app.name, {
                        number: i
                    }]
                });
            }
        }
    }

    cli.log("Action", `Start ${actions.length} processes`);

    return actions;
}

function filterInfo(info, selectors) {
    const applications = info.applications.filter((app) => {
        for (const select of selectors) {
            if (select.app === 'all' || select.app === app.name)
                return true;
        }

        return false;
    });

    const processes = {};
    let all = []; 

    for (let gen of Object.keys(info.processes)) {
        processes[gen] = info.processes[gen].filter(processFilter(gen));
        all = all.concat(processes[gen]);
    }

    function processFilter(generation) {
        return (process) => {
            for (const select of selectors) {
                if (select.gen && select.gen !== generation)
                    continue;

                if (select.app && select.app !== 'all' && select.app !== process['app-name'])
                    continue;

                if (!match('number', select, process) ||
                    !match('id', select, process) ||
                    !match('pid', select, process)) {

                    continue;
                }
                
                return true;
            }

            return false;
        };
    }

    function match(name, select, process) {
        return typeof select[name] === 'undefined' || select[name] === process[name];
    }

    return {
        applications,
        processes,
        all
    }
}
 
async function connectOrLaunch(config) {
    try {
        return await finalPM.client.connect(config['socket']);
    } catch (error) {
        if ((error.name === 'ConnectionError')) {
            if (config['is-local']) {
                cli.log("Daemon", "Starting Daemon");
                await finalPM.daemon.launch(config);
                return finalPM.client.connect(config['socket']);
            }
        } 

        throw error;
    }
}

run();
