#!/usr/bin/env node

const finalPM = require('../');
const util = require('util');
const commandLineArgs = require('command-line-args');
const commandLineUsage = require('command-line-usage');
const argsDefinition = require('../cli-args.js');
const stripAnsi = require('strip-ansi');
const ansi = require('ansi-escape-sequences');

finalPM.registerProcessHandlers();

let args;
try {
    args = commandLineArgs(argsDefinition.options, {
        partial: false,
        disableGreedyMultiple: true
    });
} catch (e) {
    invalidArgument(e.message);
}

if (args['help-usage']) {
    console.log(commandLineUsage(argsDefinition.usage));
    process.exit(0);
}

if (args['help-generations']) {
    console.log(commandLineUsage(argsDefinition.generations));
    process.exit(0);
}

if (args['help-example']) {
    console.log(commandLineUsage(argsDefinition.example));
    process.exit(0);
}

if (args['help-configuration']) {
    console.log(commandLineUsage(argsDefinition.configuration));
    process.exit(0);
}

if (args['help-all']) {
    console.log(commandLineUsage(argsDefinition.helpAll));
    process.exit(0);
}

if (args['help'] || args.actionSelect.length === 0 && !args.kill && !args.launch) {
    console.log(commandLineUsage(argsDefinition.help));
    process.exit(0);
}

if (args.actionSelect.length === 1) {
    invalidArgument("Missing option: Selector is missing.");
}
    
let action = null;
let select = [];
if (args.actionSelect.length > 1) {
    if (!argsDefinition.isKnownAction(args.actionSelect[0])) {
        invalidArgument("Unknown action: " + args.actionSelect[0]);
    }

    action = args.actionSelect[0];
    select = args.actionSelect.slice(1);
}

async function run() {
    const paths = await Promise.all(
        args.config.map(finalPM.config.resolveConfig));

    paths.forEach((path, i) => {
        if (!path) {
            err(`No configuration file found at: ${args.config[i]}`);
            process.exit(1);
        }
    });

    const configs = await Promise.all(paths.map(async (path) =>  {
        try {
            return await finalPM.config.getConfig({
                path: path,
                args: args.set
            });
        } catch (error) {
            if (error.name === 'ConfigError') {
                invalidConfig(error.path, error.message);
            }

            throw error;
        }
    }));

    const normalizedConfigs = finalPM.config.normalizeArray(configs);

    for (let config of normalizedConfigs) {
        await runWithConfig(config);
    }
}

async function runWithConfig(config) {
    debug("Connection", "Connecting to " + config.socket);

    let client;

    try {
        client = await connectOrLaunch(config);
    } catch (error) {
        if (error.name === 'ConnectionError') {
            err("Connection", error.message);
            return;
        }
        
        throw error;
    }

    const api = client.api();

    if (config.applications.length > 0 && !args['no-upload']) {
        log("Upload", "Uploading application configuration: " + config.applications.map(_ => _.name).join(' '));

        await api.Daemon.load(config.applications);
    }

    debug("Download", "Retrieving application and process lists");

    const info = filterInfo(await api.Daemon.info(), select);

    debug("Selector", `Selector matched ${info.applications.length} applications and ${info.all.length} processes`);

    if (action) {
        await runAction(api, action, info)
    }

    if (args.kill) {
        log("Daemon", "Stopping Daemon");
        await api.Daemon.kill()
    }

    debug("Connection", "Closing Connection");

    client._socket.close()
}

async function runAction(api, action, selected) {
    if (action === 'show') {
        printInfo(selected); 
        return;
    }
}

function printInfo(selected) {
    printInfoLine("Known Applications: " + selected.applications.map(_ => _.name).join(' '));
}
    
function printInfoLine(...args) {
    log("[bold green]{Show}", ...args);
}

function filterInfo(info, select) {
    const applications = info.applications.filter((app) => {
        if (select.indexOf('all') !== -1) {
            return true;
        }

        return select.indexOf(app.name) !== -1;
    });

    const processes = {};
    let all = []; 

    for (let gen of Object.keys(info.processes)) {
        processes[gen] = info.processes[gen].filter(genFilter(gen));
        all = all.concat(processes[gen]);
    }

    return {
        applications,
        processes,
        all
    }
}
    
function genFilter(gen) {
    return (process) => {
        for (let sel of select) {
            const genSep = sel.indexOf(':');

            if (genSep !== -1) {
                const selGen = sel.slice(0, genSep);
                if (selGen !== gen) {
                    continue;
                }

                sel = sel.slice(0, genSep + 1);
            }

            if (sel === 'all') {
                return true;
            }

            if (sel.startsWith('pid=')) {
                if (sel !== 'pid=' + process.pid) {
                    continue;
                }

                return true;
            }

            if (sel === process['app-name']) {
                return true;
            }
        }

        return false;
    }
}

async function connectOrLaunch(config) {
    try {
        return await finalPM.client.connect(config['socket']);
    } catch (error) {
        if ((error.name === 'ConnectionError')) {
            if (config['is-local']) {
                log("Daemon", "Starting Daemon");
                await finalPM.daemon.launch(config);
                return finalPM.client.connect(config['socket']);
            }
        } 

        throw error;
    }
}

function invalidConfig(path, ...info) {
    err("Configuration", path, ...info);
    err("Configuration", "Check \"final-pm --help\" for example configurations.");
    process.exit(1);
}

function invalidArgument(...info) {
    err("Arguments", ...info);
    err("Arguments", "Check \"final-pm --help\" for the correct syntax.");
    process.exit(1);
}

function debug(...out) {
    if (!args.verbose) return;

    console.log(makeLogLine(
        ['[gray]{DEBUG}'].concat(out),
        process.stdout.isTTY
    ));
}

function log(...args) {
    console.log(makeLogLine(
        ['[white]{INFO }'].concat(args),
        process.stdout.isTTY
    ));
}

function err(...args) {
    console.error(makeLogLine(
        ['[red]{ERROR}'].concat(args),
        process.stderr.isTTY
    ));
}

function makeLogLine(args, format) {
    const last = args[args.length - 1];
    const pre = `[[bold]{${args.slice(0, args.length - 1).join('}] [[bold]{')}}] `;
    const line = ansi.format(last.split('\n').map(line => pre + line).join('\n'));
    
    if (format) {
        return line;
    }

    return stripAnsi(line);
}

run();
